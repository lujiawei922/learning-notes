vnote_backup_file_826537664 E:/vnote_notebooks/软件设计师/算法.md
# 算法
![](_v_images/20210321192814884_32236.png)

## 算法复杂度
![](_v_images/20210321200415981_20101.png)

## 顺序查找与二分查找
* 顺序查找
![](_v_images/20210321200835284_14564.png)
时间复杂度（On）
* 二分查找
![](_v_images/20210321201011915_22134.png)

![](_v_images/20210321201131763_21534.png)
时间复杂度为log2N

## 散列表
![](_v_images/20210321201439475_21178.png)

## 排序
![](_v_images/20210321202039124_16414.png)

### 直接插入排序
![](_v_images/20210321202201213_3198.png)

### 希尔排序
![](_v_images/20210321202542411_14629.png)

比起插入排序，希尔排序是先进行大致的排序，然后再进行插入排序

### 直接选择排序
![](_v_images/20210321203011099_20359.png)

### 堆排序
![](_v_images/20210321203917018_592.png)
小顶堆即指所有的孩子结点都大于根结点
大顶堆即指所有的孩子结点都小于根结点

* 初建堆过程
![](_v_images/20210321204411756_26459.png)
1.1 按顺序建立完整二叉树
1.2 找出所有的非叶子结点（1,3,4,5）。从后往前依次跟孩子结点比较跟最大孩子进行交换，该图也对5的节点进行调整。
1.3 对节点4进行调整（类似5的操作）
1.4 对结点3调整是需要进行多级调整，先3和8进行交换
1.5 再让3和5进行交换
1.6 对结点1进行调整，1和8进行交换
1.7 1和7进行交换 （大顶堆完成）

* 对堆进行排序
![](_v_images/20210321205235947_25209.png)
(a) 取出最大结点80
(b) - （f）将最后的结点20放到根结点，然后再依照初建堆的过程进行堆排序
重复上诉步骤知道取完所有结点

### 冒泡排序
![](_v_images/20210321205712227_19219.png)

### 快速排序
![](_v_images/20210321205922402_14678.png)

### 归并排序
![](_v_images/20210321210637267_30321.png)
本质是将问题拆分成多个子问题，然后解决，归并后按照相同的方法再次处理，再归并

### 基数排序
![](_v_images/20210321210706642_1512.png)

## 排序算法时间复杂度和稳定性
![](_v_images/20210321210935786_18660.png)