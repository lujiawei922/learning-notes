vnote_backup_file_826537664 E:/vnote_notebooks/软件设计师/数据结构.md
# 数据结构
## 数组
![](_v_images/20210320214632923_4759.png)

### 稀疏矩阵
![](_v_images/20210320215250500_26999.png)

## 线性表
### 链表基本操作
![](_v_images/20210320220325157_22767.png)

### 顺序存储与链式存储对比
![](_v_images/20210320220453045_32417.png)

### 队列和栈
![](_v_images/20210320221352892_10662.png)

## 广义表
![](_v_images/20210320222152034_6618.png)

## 树与二叉树
![](_v_images/20210320222342316_12901.png)

结点的度：结点子节点的个数
树的度：最大结点的度
叶子结点：没有子结点的结点
分支结点：有相应的分支的结点
内部结点：非叶子结点与根节点
层次：有多少层

### 二叉树
![](_v_images/20210320223016964_16397.png)

### 二叉树遍历
![](_v_images/20210320224209962_23337.png)
前序遍历：先访问根节点，再访问左子树，再访问右子树，（1,2,4,5,7,8,3,6）
中序遍历：先访问左子树节点，再访问根节点，再访问右子树（4,2,7,8,5,1,3,6）
后序遍历：先访问左子树节点，在访问右子树节点，再访问根节点（4,8,7,5,2,6,3,1）
层次遍历：1，2，3，4，5，6，7，8
### 反向构造二叉树
![](_v_images/20210320230030106_8139.png)

![](_v_images/20210320230041034_10606.png)

### 树转二叉树
![](_v_images/20210320230344394_31130.png)

### 查找二叉树
![](_v_images/20210320231443539_9929.png)

### 最优二叉树（哈夫曼树）
![](_v_images/20210320232130241_22356.png)
树的路径长度：经历路径长度
权：某个叶子结点的数值，代表某个字符出现的频率
带权的路径长度：路径长度 * 权值（例如求2的带权的路径长度 2 * 2 = 4）
树的带权路径长度（树的代价） 所有带权路径长度之和
所谓的哈夫曼树指的是最小的树的带权路径长度

### 线索二叉树
![](_v_images/20210321184736677_2652.png)

前序遍历顺序：ABDEHCFGI 前序遍历。为空指针的结点分别左空指针指向前序遍历的前驱节点，右空指针指向后继结点，比如H的前驱结点为E，后继结点为C。中序和后序一样处理

### 平衡二叉树
![](_v_images/20210321190008684_24230.png)

## 图的概念及存储
![](_v_images/20210321190424923_21691.png)

![](_v_images/20210321191052252_6289.png)
邻接矩阵有对称性。因此可以只存上三角或者下三角

![](_v_images/20210321191239971_7674.png)

### 图的遍历
![](_v_images/20210321191450550_4464.png)

### 拓扑排序
![](_v_images/20210321191714533_2223.png)

### 图的最小生成树
* 普里姆算法
![](_v_images/20210321192332356_22524.png)
以红点出发选择最近的点连线，在被连入的点中找最近的为连接的点进行连线，连的线不能闭环。

* 克鲁斯卡尔算法
![](_v_images/20210321192631692_3365.png)
选择节点数n - 1的最短线进行相连
